require 'temporalio/activity'
require 'faraday'
require 'json'
require 'logger'

# Create a module to include in all activity classes
module ActivityLogging
  def logger
    @logger ||= Logger.new(STDOUT).tap do |l|
      l.level = Logger::INFO
      l.formatter = proc do |severity, datetime, progname, msg|
        "[#{datetime}] #{severity}: [ACTIVITY] #{msg}\n"
      end
    end
  end
end

class RunFraudCheckActivity < Temporalio::Activity::Definition
  include ActivityLogging
  def execute(payment_data)
    logger.info "Running fraud check for transaction: #{payment_data[:amount]} #{payment_data[:charge_currency]}"
    
    # First check if Compliance API is up with a short timeout
    begin
      conn = Faraday.new(url: 'http://localhost:3002') do |f|
        f.options.timeout = 2  # 2 second timeout for demo
        f.options.open_timeout = 1
      end
      
      # Call the fraud check endpoint
      response = conn.post('/api/checks/fraud') do |req|
        req.headers['Content-Type'] = 'application/json'
        req.body = {
          amount: payment_data[:amount],
          charge_currency: payment_data[:charge_currency],
          settlement_currency: payment_data[:settlement_currency],
          customer: payment_data[:customer],
          merchant: payment_data[:merchant]
        }.to_json
      end
      
      result = JSON.parse(response.body)
      
      if response.status != 200
        error_message = "Fraud check failed: #{result['reason'] || 'Unknown error'}"
        logger.error "⚠️ #{error_message}"
        
        # Raise a Temporal error that will fail the workflow
        raise RuntimeError, "#{error_message} (Risk score: #{result['risk_score']})"
      end
      
      logger.info "✅ Fraud check passed with risk score: #{result['risk_score']}"
      
      return {
        success: true,
        result: result['result'],
        risk_score: result['risk_score']
      }
    rescue Faraday::Error => e
      # API connection error - THIS WILL HAPPEN WHEN COMPLIANCE API IS DOWN
      error_message = "Compliance API unavailable: #{e.message}"
      logger.error "⚠️⚠️⚠️ #{error_message}"
      
      # Raise a non-retryable error that will fail the workflow
      # This will ensure the workflow shows as failed in Temporal UI
      raise RuntimeError.new(
        error_message,
        details: { service: 'compliance_api' },
        type: 'compliance_api_down',
        non_retryable: true
      )
    end
  end
end

class RunAmlCheckActivity < Temporalio::Activity::Definition
  include ActivityLogging
  def execute(payment_data)
    logger.info "Running AML check for transaction: #{payment_data[:amount]} #{payment_data[:charge_currency]}"
    
    # First check if Compliance API is up with a short timeout
    begin
      conn = Faraday.new(url: 'http://localhost:3002') do |f|
        f.options.timeout = 2  # 2 second timeout for demo
        f.options.open_timeout = 1
      end
      
      # Call the AML check endpoint
      response = conn.post('/api/checks/aml') do |req|
        req.headers['Content-Type'] = 'application/json'
        req.body = {
          amount: payment_data[:amount],
          charge_currency: payment_data[:charge_currency],
          settlement_currency: payment_data[:settlement_currency],
          customer: payment_data[:customer],
          merchant: payment_data[:merchant]
        }.to_json
      end
      
      result = JSON.parse(response.body)
      
      if response.status != 200
        error_message = "AML check failed: #{result['reason'] || 'Unknown error'}"
        logger.error "⚠️ #{error_message}"
        
        # Raise a Temporal error that will fail the workflow
        raise RuntimeError, "#{error_message} (AML score: #{result['aml_score']})"
      end
      
      logger.info "✅ AML check passed with score: #{result['aml_score']}"
      
      return {
        success: true,
        result: result['result'],
        aml_score: result['aml_score']
      }
    rescue Faraday::Error => e
      # API connection error - THIS WILL HAPPEN WHEN COMPLIANCE API IS DOWN
      error_message = "Compliance API unavailable: #{e.message}"
      logger.error "⚠️⚠️⚠️ #{error_message}"
      
      # Raise a non-retryable error that will fail the workflow
      # This will ensure the workflow shows as failed in Temporal UI
      raise RuntimeError.new(
        error_message,
        details: { service: 'compliance_api' },
        type: 'compliance_api_down',
        non_retryable: true
      )
    end
  end
end

class RunSanctionsCheckActivity < Temporalio::Activity::Definition
  include ActivityLogging
  def execute(payment_data)
    logger.info "Running sanctions check for transaction: #{payment_data[:amount]} #{payment_data[:charge_currency]}"
    
    # Connect to Compliance API
    conn = Faraday.new(url: 'http://localhost:3002')
    
    # Call the sanctions check endpoint
    response = conn.post('/api/checks/sanctions') do |req|
      req.headers['Content-Type'] = 'application/json'
      req.body = {
        amount: payment_data[:amount],
        charge_currency: payment_data[:charge_currency],
        settlement_currency: payment_data[:settlement_currency],
        customer: payment_data[:customer],
        merchant: payment_data[:merchant]
      }.to_json
    end
    
    result = JSON.parse(response.body)
    
    if response.status != 200
      logger.error "Sanctions check failed: #{result['reason'] || 'Unknown error'}"
      return {
        success: false,
        result: 'failed',
        reason: result['reason'] || 'Unknown error',
        details: result['details']
      }
    end
    
    logger.info "Sanctions check passed: #{result['details']}"
    
    return {
      success: true,
      result: result['result'],
      details: result['details']
    }
  end
end
